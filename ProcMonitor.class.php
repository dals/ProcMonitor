<?php
define("PM_TEMP_DIR","/tmp");

/**
 * ProcMonitor Class
 *
 * Simple process spawning and monitoring.
 * Designed to be used in combination with AJAX for monitoring
 * the progress of server side executions.
 * Example: {@example ./examples/example.php}
 * 
 * @author Jamie Wong <jamie.lf.wong@gmail.com>
 * @link http://jamie-wong.com
 */
class ProcMonitor {

	/**
	 * Gets the filename of the temporary file receiving output from the process
	 * @param string $fileId The unique file id generated by ProcMonitor::Start
	 * @see ProcMonitor::Start()
	 * @see ProcMonitor::GetBytesFName()
	 */
	protected function GetFName($fileId) {
		return sprintf("%s/%s.txt",
			PM_TEMP_DIR,
			$fileId
		);
	}

	/**
	 * Gets the filename storing the number of bytes read
	 * @param string $fileId The unique file id generated by ProcMonitor::Start
	 * @see ProcMonitor::Start()
	 * @see ProcMonitor::GetFName()
	 */
	protected function GetBytesFName($fileId) {
		return sprintf("%s/%s_bytes_read.txt",
			PM_TEMP_DIR,
			$fileId
		);
	}

	/**
	 * Gets the number of bytes read from the output of the process
	 * @param string $fileId The unique file id generated by ProcMonitor::Start
	 * @see ProcMonitor::Start()
	 * @see ProcMonitor::SetBytesRead()
	 */
	protected function GetBytesRead($fileId) {
		$handle = fopen( ProcMonitor::GetBytesFName($fileId), "r" );
		$bytesRead = (int)fread($handle,1024);
		fclose($handle);
		return $bytesRead;
	}

	/**
	 * Updates the file with the number of output bytes read
	 * @param $fileId The unique file id generated by ProcMonitor::start
	 * @param $bytesRead The updated number of bytes read
	 * @see ProcMonitor::Start()
	 * @see ProcMonitor::GetBytesRead()
	 */
	protected function SetBytesRead($fileId,$bytesRead) {
		$handle = fopen( ProcMonitor::GetBytesFName($fileId), "w" );
		fputs($handle,"$bytesRead\n");
		fclose($handle);
	}


	/**
	 * Spawn the process, return the temp. file id and the process id
	 * @param string $cmd The command to execute
	 * @return mixed An array containing
	 *
	 * array[0]: the temporary file id
	 * array[1]: the process id
	 */
	public function Start($cmd) {
		$fileId = md5(uniqid());

		ProcMonitor::SetBytesRead($fileId,0);

		$cmd .= " > ".ProcMonitor::GetFName($fileId);
		$cmd .= " 2> ".ProcMonitor::GetFName($fileId);
		$cmd .= " & echo $!";

		exec($cmd,$info);
		$procId = (int)$info[0];

		return array($fileId,$procId);
	}

	/**
	 * Returns the next line output by the process, up to $maxbytes bytes
	 * @param string $fileId the unique file id generated by ProcMonitor::Start
	 * @param int $maxbytes the maximum number of bytes to retrieve from a line
	 * @return string a line of output from the process
	 */
	public function GetOutput($fileId,$maxbytes = 1024) {
		$handle = fopen(ProcMonitor::GetFName($fileId),"r");
		$bytesRead = procMonitor::GetBytesRead($fileId);

		fseek($handle,$bytesRead);
		$output = fgets($handle,$maxbytes);
		$bytesRead += strlen($output);
		ProcMonitor::SetBytesRead($fileId,$bytesRead);

		return $output;
	}

	/**
	 * Return whether or not output is waiting to be read (still in the buffer)
	 * @param string $fileId the unique file id generated by ProcMonitor::Start
	 * @return bool True: Output is in the buffer, False: Output buffer is empty
	 * @see ProcMonitor::GetOutput
	 * @see ProcMonitor::Start
	 */
	public function OutputWaiting($fileId) {
		$handle = fopen(ProcMonitor::GetFName($fileId),"r");
		$fstat = fstat($handle);
		fclose($handle);

		if ($fstat['size'] > ProcMonitor::GetBytesRead($fileId)) {
			return true;
		} else {
			return false;
		}
	}

	/**
	 * Returns whether or not the process with pid $procId is running
	 * @param int $procId The pid to lookup
	 * @return bool True: Process is running, False: Process has terminated
	 */
	public function Running($procId) {
		exec("ps -p $procId",$info);
		if (count($info) > 1) {
			return true;
		} else {
			return false;
		}
	}

	/**
	 * Terminates the process and deletes the temporary files
	 * @param string $fileId the unique file id generated by ProcMonitor::Start
	 * @param int $procId the pid of the process to kill
	 * @see ProcMonitor::Start()
	 */
	public function Close($fileId,$procId) {
		posix_kill($procId,15);		
		unlink(ProcMonitor::GetFName($fileId));
		unlink(ProcMonitor::GetBytesFName($fileId));
	}
}

?>
